the world is concurrent
things in the world don't share data
things communicate with messages
things fail
并行,不共享,消息传递,容易失败

以前对一些类中持有一大堆其他类的引用感到很烦,不知道为什么需要这么多
一个对象持有其他对象的引用是正常的,
这样我们才能更好的定义该对象本身的一些行为,专注于该对象本身的特性
# 容错机制
    如果发生了xxx,能不能自动处理
    也就是针对一些可能发生的异常写了相应的处理代码
    
    数据的容错
    数据检查点:执行数据的拷贝过程
    记录数据的更新:只记录哪些数据更新了数据,每条记录的更新都会记录下来


# 数据是什么?
	数据是一堆字节和其定义在其上的操作
    这样的数据才有意义,要不然只有一堆字节的话,在每个人看来都可以有不同的意思
    ,只有其上的操作定义了其才有意义
	在代码中就是定义其变量,然后变为私有的类型,使得其他人不可直接访问该
	变量,而是通过我们自己定义的一些public的方法来访问,只要正确定义了其上
	的操作方法,那么也就定义了其数据的真正含义
	
	那么状态是什么呢？
	状态就是一堆数据的
	
# 抽象和具体实现
    PC程序计数器是一个抽象的概念
    CS:IP寄存器是其具体的实现
    局域网是一个抽象概念
    以太网是其具体实现


硬件错误是常态，因此需要冗余
在计算机中的数据的保存和运算都是以二进制的形式进行的,
但不是直接的原码,
而是原码的补码,也就是说在计算机中,数据的运算都是以数据的补码进行的
	
将一个字符串映射到一个数组中时,你只能得到其指定位置是否存在,但是得不到其映射时的输入顺序

		
什么是锁

在单进程的系统中，当存在多个线程可以同时改变某个变量（可变共享变量）时，就需要对变量或代码块做同步，
使其在修改这种变量时能够线性执行消除并发修改变量。

而同步的本质是通过锁来实现的。为了实现多个线程在一个时刻同一个代码块只能有一个线程可执行，
那么需要在某个地方做个标记，这个标记必须每个线程都能看到，当标记不存在时可以设置该标记，
其余后续线程发现已经有标记了则等待拥有标记的线程结束同步代码块取消标记后再去尝试设置标记。
这个标记可以理解为锁。

不同地方实现锁的方式也不一样，只要能满足所有线程都能看得到标记即可。如java中synchronize是在对象头设置标记，Lock接口的实现类基本上都只是某一个volitile修饰的int型变量其保证灭个线程都能拥有对该int的可见性和原子修改，linux内核中也是利用互斥量或信号量等内存数据做标记。
除了利用内存数据做锁其实任何互斥的都能做锁（只考虑互斥情况），如流水表中流水号与时间结合做幂等校验可以看作是一个不会释放的锁，或者使用某个文件是否存在作为锁等。只需要满足在对标记进行修改能保证原子性和内存可见性即可。


leader和follow模型
假设有n个线程，那么其中一个线程为leader，该线程监听网络，发现连接后负责处理该连接，当该线程处理一个连接时，该线程成为follower，其他的空闲follower通过竞争成为新的leader，这样的好处是避免了线程切换带来的开销。


数据不可能凭空消失,除非你没向外输出
数据不在你认为的地方,那么可能有其他个体对数据进行了操作

表达式和语句的区别
    表达式可以求值
    语句就是一条
使用异常还是返回错误码

如何测试一个数组是否包含指定的值?
    Arrays.asList(...).contains(...)
    使用 Apache Commons Lang包中的ArrayUtils.contains
    自己写逻辑
    如果数组有序(二分查找)
    如果数组无序
    方法很多，但问题的本质只是在给定的数组中查找具体的值
    相等的判断条件？
    不同语言提供的API不同写的方式自然也不同，风格不一样
    至于简单和优雅只是将搜索功能封装了而已，然后只要调用相应的函数就行
在数据层面OO和FP有什么区别?
OO
    数据和数据操作是紧耦合的
    核心是数据,然后基于数据构建相应的模型
FP
    数据和数据操作是松耦合的
    核心是函数,不是数据
OO以数据作为核心
FP以函数作为核心

OO需要我们一步一步指定怎么做
FP只需要我们想好我们需要什么,然后通过组合函数自己玩去
# 表驱动法
>表驱动法是一种编程模式,从表里面查询信息而不使用逻辑语句(如if或switch)  
事实上凡是能使用逻辑语句解决的问题都可以通过查表解决,但当逻辑嵌套越深时,我们理解和整理起来就越发吃力
* 通过逻辑来解决相当于多使用我们的大脑,
而通过查表解决相当于我们将数据都写在了书上,也就是相当于一个CPU和内存的权衡
,多使用CPU还是多使用内存.
* 表驱动法是什么
* 不使用表驱动法有什么问题?(也就是传统的写法有啥劣势)
* 表驱动法如何写?(怎么做)
    直接访问
    索引访问(哈希)
    阶梯访问(范围记录)
* 优势
    + 可以将表里面的数据存放在外部存储中,这样也就代表这我们可以在不改变程序的情况下调控一些参数
# 数据驱动编程
>更普遍的是，战略上突破常来自数据或表的重新表达――这是程序的核心所在。如果提供了程序流程图，
而没有表数据，我仍然会很迷惑。而给我看表数据，往往就不再需要流程图，程序结构是非常清晰的。
由于缺乏空间而绞尽脑汁的编程人员，常常能通过从自己的代码中挣脱出来，回顾、分析实际情况，
仔细考虑程序的数据，最终获得非常好的结果。实际上，数据的表现形式是编程的根本，

数据驱动编程的核心出发点是相对于程序逻辑，人类更擅长于处理数据。数据比程序逻辑更容易驾驭，所以我们应该尽可能的将设计的复杂度从程序代码转移至数据

数据压倒一切。如果选择了正确的数据结构并把一切组织的井井有条，正确的算法就不言自明。编程的核心是数据结构，而不是算法
# 类型类是什么
1和'a'
存储方式是一样的，都是二进制存储
但对我们来说直觉上他们应该不是同一种东西
而是我们以不同的类型来将其划分
于是就有了整型,字符串等等其他类型
在值的概念上建立了一种抽象
不同的值具有不同的属性
不同的值也就有了不同的行为
# 变化
    从更高层的抽象思考问题
    在每一个可能发生变化的地方提供相应的接口
    代码的运行路径就像我们人在空间的行走路径一样,每走一步都可以有无数种选择,上下左右前后,甚至斜方向
    一步有无数种,那一条运行路径就有无数个无数
    但是我们平常都只是走自己熟悉的路,过滤了其中大半部分,所以有规律可循,代码也是为人服务的,所以也可以总结出
    相应的规律,但如果其中某一步需要变化时,好的代码会提前在每一个可能变化的地方预留处理方法
    
# 可靠稳定一致的系统我们需要考虑哪些硬件问题
    先想下有哪些通用硬件
        磁盘,内存,CPU,网络
    磁盘空间不足
    内存不足
    网络阻塞
    网络断开
    系统崩溃
# 统一访问原则
    某个模块提供的所有服务都应该能通过统一的表示法访问到，至于它们是通过存储还是通过计算来实现的，从访问方式上应无从获知
    
java不会等到把程序中用到的所有类都装载完后才开始运行程序，它只在需要时才装载相应的类



一个对象持有其他对象的引用是正常的,
这样我们才能更好的定义该对象本身的一些行为,专注于该对象本身的特性

代码点和代码单元
代码点是Unicode字符集中的一个数字,该数字被我们认为是某一个汉字
utf-8采用1-4个代码单元对其进行编码,utf-16采用2个代码单元对其进行编码
utf-32采用4个代码单元对其进行编码


计算机的本质是一个状态机，内存里存储的所有数据构成了当前的状态，
CPU只能利用当前的状态计算出下一个状态（不要纠结硬盘之类的外部存储，
就算考虑他们也只是扩大了状态的存储容量而已，
并不能改变下一个状态只能从当前状态计算出来这一条铁律）当你企图使用计算机解决一个问题是，
其实就是在思考如何将这个问题表达成状态（用哪些变量存储哪些数据）以及如何在状态中转移（怎样根据一些变量计算出另一些变量）。
所以所谓的空间复杂度就是为了支持你的计算所必需存储的状态最多有多少，所谓时间复杂度就是从初始状态到达最终状态中间需要多少步！

如果一个算法的执行次数是 T(n)，那么只保留最高次项，同时忽略最高项的系数后得到函数 f(n)，
此时算法的时间复杂度就是 O(f(n))。为了方便描述，下文称此为 大O推导法。



每个阶段只有一个状态->递推；
每个阶段的最优状态都是由上一个阶段的最优状态得到的->贪心；
每个阶段的最优状态是由之前所有阶段的状态的组合得到的->搜索；
每个阶段的最优状态可以从之前某个阶段的某个或某些状态直接得到而不管之前这个状态是如何得到的->动态规划。


加密和编码的区别

编码是对数据进行转换的过程，以便它可以在通信信道上无危险地传输，或在存储介质上无危险地存储。
例如，计算机硬件不处理文本，它只是操纵字节，所以文本编码是文本应该如何转换为字节的描述。
同样，HTTP不允许安全传输所有字符，因此可能需要使用base64编码数据（仅使用字母，数字和两个安全字符）。

编码或解码时，重点放在每个人都有相同的算法，该算法通常是有据可查的，分布广泛和相当容易实现。任何人最终都能够解码编码数据。

另一方面，加密对一部分数据进行了转换，只能通过对如何解密该数据的特定（和秘密）知识进行逆转。
重点是让除预期收件人以外的任何人都难以阅读原始数据。保密的编码算法是一种加密方式，
但是非常脆弱（需要花费技巧和时间来设计任何类型的加密，
根据定义，您不能让其他人为您创建这样的编码算法 - 否则必须杀死他们）。
相反，最常用的加密方法使用密钥：算法是众所周知的，但加密和解密过程要求两个操作具有相同的密钥，然后密钥保密。
解密加密数据只能通过相应的密钥进行。


遍历过程中需要修改数据怎么办
设置一个变量,每次修改的时候更新该变量的值,规定遍历的时候需要比较该值是否与刚开始遍历的时候的值相等,如果不相等则
抛出异常,这就是快速失败

java并发包下的安全失败也没有好到哪里去,遍历的时候他会从原始数据复制一份,然后在复制的这份数据上遍历,
并且遍历期间如果有其他线程修改了原始数据,遍历时是看不到的,因为遍历是用的是最开始复制的那一份,有点像
写时复制


volatile关键字,可见性和有序性,有序是因为CPU会乱序执行指令,而有些多线程的程序不同的推进顺序会造成不同的结果,所以此时需要CPU按照我们的意愿来运行
可见性,现在的CPU是多个核,每个核都有自己的缓存,一级二级三级,当某个当CPU更新一个缓存中的变量的时候其他CPU并不能得到相应的通知,所以其他CPU并不能看到改变量的新值,然后出现了MESI协议,这个协议规定了CPU缓存间如何保持一致性,
通过四种状态,M修改,E独占,S共享,I失效,一个变量进入CPU缓存首先是E状态,如果另一个核也加载了改变了,则都变成S状态,
当其中一个核修改了改变量后,他首先通知其他CPU置为无效状态,然后等待返回结果,然后修改自己CPU的位M状态
,然后写回到主存,
>>>>>>> tmp
